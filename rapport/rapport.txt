Rapport dÃ©taillÃ© â€“ Simulateur IA dâ€™Ã©valuation immobiliÃ¨re
ğŸ“Œ 1. MÃ©thodologie adoptÃ©e
Lâ€™objectif principal est de concevoir un modÃ¨le de rÃ©gression supervisÃ© permettant dâ€™estimer le prix des appartements Ã  partir de caractÃ©ristiques clÃ©s (surface, ville, Ã©quipements, etc.), adaptÃ© au marchÃ© marocain. La dÃ©marche suivie repose sur :

Analyse exploratoire des donnÃ©es (EDA)

Nettoyage et prÃ©traitement des donnÃ©es

EntraÃ®nement et Ã©valuation de plusieurs modÃ¨les de rÃ©gression

SÃ©lection du meilleur modÃ¨le

Exportation du modÃ¨le final pour intÃ©gration web

ğŸ“Š 2. Analyse exploratoire des donnÃ©es (EDA)
Chargement des donnÃ©es : Importation via pandas.

Dimensions : Taille du dataset vÃ©rifiÃ©e via df.shape.

Types et structure : df.info() utilisÃ© pour analyser les colonnes.

Valeurs manquantes : Identification avec df.isnull().sum().

Doublons : Suppression aprÃ¨s dÃ©tection (df.drop_duplicates()).

Analyse des distributions :

Visualisation des variables numÃ©riques avec des histogrammes (sns.histplot).

Identification des tendances gÃ©nÃ©rales sur surface_area et price.

CorrÃ©lations :

Calcul dâ€™une matrice de corrÃ©lation.

Visualisation avec heatmap pour observer les variables liÃ©es au prix.

Visualisation relationnelle :

Scatterplot surface_area vs price pour constater leur relation positive.

ğŸ› ï¸ 3. PrÃ©traitement des donnÃ©es
Nettoyage & transformation :

Extraction des Ã©quipements en colonnes boolÃ©ennes via str.get_dummies().

Conversion de la colonne price en float aprÃ¨s nettoyage des caractÃ¨res non numÃ©riques.

Suppression des colonnes inutiles : equipment, link, title.

Traitement des villes :

Conversion des noms des villes de lâ€™arabe vers le franÃ§ais via un dictionnaire de correspondance.

Remplacement des villes manquantes par "Unknown".

Gestion des valeurs manquantes :

Colonnes numÃ©riques : Imputation avec la mÃ©diane.

Colonnes catÃ©gorielles : Remplacement par "Unknown".

DÃ©tection et suppression des valeurs aberrantes :

PrÃ©vu via analyse des colonnes clÃ©s comme price et surface_area.

MÃ©thodes suggÃ©rÃ©es : IQR, Z-score.

Encodage des variables catÃ©gorielles :

Label Encoding appliquÃ© sur city_name.

Mise Ã  lâ€™Ã©chelle :

PrÃ©vu via StandardScaler ou MinMaxScaler (Ã  confirmer selon les modÃ¨les).

SÃ©lection des variables explicatives :

Variables numÃ©riques avec une corrÃ©lation > 0.15 conservÃ©es.

SÃ©paration des donnÃ©es :

Variable cible : y = df["price"].

Variables explicatives : X Ã  partir des colonnes sÃ©lectionnÃ©es.

Split 80% / 20% avec train_test_split.

ğŸ¤– 4. ModÃ¨les de rÃ©gression testÃ©s
Les modÃ¨les entraÃ®nÃ©s sont :

RÃ©gression LinÃ©aire

Random Forest Regressor

SVR (Support Vector Regressor)

Gradient Boosting Regressor

Chaque modÃ¨le est Ã©valuÃ© selon :

MSE (Mean Squared Error)

RMSE (Root Mean Squared Error)

MAE (Mean Absolute Error)

RÂ² Score

Une validation croisÃ©e (Cross-Validation) est utilisÃ©e pour plus de robustesse.

Les hyperparamÃ¨tres des modÃ¨les sont optimisÃ©s avec :

GridSearchCV ou RandomizedSearchCV

ğŸ† 5. RÃ©sultats & conclusion
Le Random Forest Regressor et le Gradient Boosting obtiennent gÃ©nÃ©ralement de meilleurs rÃ©sultats sur ce type de donnÃ©es, mais cela dÃ©pend des rÃ©sultats finaux du notebook.

Le meilleur modÃ¨le est sÃ©lectionnÃ© selon un RÂ² Ã©levÃ© et un RMSE faible.

Le modÃ¨le final est exportÃ© dans un fichier model.pkl pour intÃ©gration dans lâ€™application web.


project/
â”‚
â”œâ”€â”€ data/
â”‚   â””â”€â”€ appartements-data-db.csv
â”‚
â”œâ”€â”€ models/
â”‚   â””â”€â”€ model.pkl               # ModÃ¨le final exportÃ©
â”‚
â”œâ”€â”€ notebooks/
â”‚   â””â”€â”€ project.ipynb           # Notebook principal (ce fichier)
â”‚
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ preprocess.py           # (optionnel) PrÃ©traitement sous forme de script
â”‚   â””â”€â”€ train_model.py          # (optionnel) EntraÃ®nement sous forme de script
â”‚
â””â”€â”€ README.md                   # Instructions dâ€™exÃ©cution

